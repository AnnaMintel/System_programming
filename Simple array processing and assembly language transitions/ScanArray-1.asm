.686
.model flat, stdcall
include	macroses.inc

.data
include vars.inc

n EQU 20		;Задаем константу n равную 20
mas DD n DUP(?)	;Задаем массив "mаs" из n элементов, каждый элемент длиной 32 бита (DD), неинициализирован (?)
razmer DD 0		;Задаем переменную и инициализируем ее (=0)

.code
include procedures.inc

WinMain PROC
	
	INIT_CONSOLE
	WRITE 'Введите размер массива (от2 до 20) - '
	INVOKE READNUMBER
	mov razmer, eax

	WRITELN 'Введите элементы массива:'
	mov ecx, razmer      ; загружаем в ЕСХ число элементов массива введенное с экрана
	mov ebx, OFFSET mas  ;загружаем в EBX начальный адрес массива
input1:
	INVOKE READNUMBER	 ; читаем введенное число
	mov [ebx], eax		 ; и пишем его в ячейку, адрес которой сейчас в EBX
	add ebx, 4			; увеличиваем значение адреса в EBX на 4 (каждое число массива по 4 байта - 32 бита (DD)
	loop input1			; циклимся пока не переберем все элементы (пока ECX не станет равным 0)
	
	lea esi, mas	; загружаем в регистр ESI начальный адрес массива 
	mov ecx, SIZEOF mas	; определяем размерность массива и заносим ее в регистр EСX
	xor edx, edx		; обнуление регистра EDX - подготовка для подсчета "ненулей"

start:
	mov al, [esi] ; значение младшей части элемента массива, расположенного по адресу в регистре ESI- в регистр AL
	inc esi       ; увеличиваем адрес очередного элемента массива
	cmp al, 5			; сравнение с числом 5
	jle skip		; переход если равно (5) - обход увеличения EDX
	inc edx		; увеличение счетчика элементов если CMP дал не "меньше или равно 5"		
skip:
	loop start			; если ECX больше нуля - не последний элеиент массива, 
						; то переходим на метку start и уменьшаем ECX на 1, если ECX=0 - последний элемент
	WRITELN ' '
	WRITE 'Число элементов массива больше чем 5 = '
	WRITE_NUMBER edx	; вывод на экран количества в массиве чисел больше 5
	

	READLN_CONSOLE
    INVOKE ExitProcess, 0
WinMain ENDP

end WinMain